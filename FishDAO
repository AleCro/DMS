import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Data access object (DAO) for managing {@link Fish} records in the
 * Florida Native Fish Database Management System (DMS).
 *
 * <p>Purpose:</p>
 * <p>
 * This class encapsulates all persistence-related operations for {@code Fish}
 * objects. It supports both:
 * </p>
 * <ul>
 *     <li>Mock mode (in-memory list) for testing without a database, and</li>
 *     <li>JDBC mode for SQLite database integration.</li>
 * </ul>
 *
 * <p>Primary responsibilities:</p>
 * <ul>
 *     <li>Connecting to and disconnecting from a SQLite database.</li>
 *     <li>Performing CRUD operations (create, read, update, delete) on fish records.</li>
 *     <li>Providing a custom calculation feature to compute the average fish size.</li>
 *     <li>Validating {@link Fish} objects before insert or update.</li>
 * </ul>
 *
 * <p>Typical usage example:</p>
 * <pre>{@code
 * FishDAO dao = new FishDAO();
 * boolean connected = dao.connect("fish.db");
 * List<Fish> allFish = dao.getAllFish();
 * double avgSize = dao.calculateAverageFishSize();
 * dao.disconnect();
 * }</pre>
 */
public class FishDAO {

    /** In-memory mock storage (used when not connected to a database). */
    private final List<Fish> mockFishList = new ArrayList<>();

    /** JDBC connection object for database operations. */
    private Connection connection = null;

    /** Flag indicating whether the system is connected to the database. */
    private boolean useDatabase = false;

    /**
     * Creates a new {@code FishDAO} in mock mode by default.
     * <p>
     * The caller must invoke {@link #connect(String)} to enable database-backed
     * operations; otherwise, methods will operate on the in-memory list.
     * </p>
     */
    public FishDAO() {}

    /**
     * Attempts to connect to a SQLite database file.
     * <p>
     * If the connection fails or an invalid path is provided, the DAO falls back
     * to mock mode (local in-memory list) and returns {@code false}.
     * </p>
     *
     * @param dbPath path to the SQLite database file
     * @return {@code true} if the connection was successful; {@code false} otherwise
     */
    public boolean connect(String dbPath) {
        try {
            if (dbPath == null || dbPath.isEmpty()) {
                useDatabase = false;
                return false;
            }

            String url = "jdbc:sqlite:" + dbPath;
            connection = DriverManager.getConnection(url);
            useDatabase = true;
            System.out.println("✔ Connected to SQLite database successfully.");
            return true;
        } catch (SQLException e) {
            System.out.println("⚠ Failed to connect to database: " + e.getMessage());
            System.out.println("➡ Switching to mock (local list) mode instead.");
            useDatabase = false;
            connection = null;
            return false;
        }
    }

    /**
     * Closes the current database connection (if any) and switches to mock mode.
     *
     * @return {@code true} if any active connection was successfully closed
     *         or if no connection existed; {@code false} if an error occurred
     */
    public boolean disconnect() {
        try {
            if (useDatabase && connection != null) {
                connection.close();
                System.out.println("⚠ Database connection closed.");
            } else {
                System.out.println("Mock mode active — nothing to disconnect.");
            }
        } catch (SQLException e) {
            System.out.println("⚠ Error closing database: " + e.getMessage());
            return false;
        } finally {
            useDatabase = false;
            connection = null;
        }
        return true;
    }

    /**
     * Adds a new {@link Fish} record.
     * <p>
     * The method validates required fields and rejects invalid objects before
     * attempting to insert into the database or mock list.
     * </p>
     *
     * @param fish the {@link Fish} object to add
     * @return {@code true} if successfully added; {@code false} otherwise
     */
    public boolean addFish(Fish fish) {
        if (fish == null) return false;
        if (!validateFish(fish)) return false;

        if (useDatabase) {
            String sql = "INSERT INTO fish_records " +
                    "(common_name, scientific_name, average_size, measurement_unit, diet, habitats, conservation_status, tag) " +
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, fish.getCommonName());
                stmt.setString(2, fish.getScientificName());
                stmt.setDouble(3, fish.getAverageSize());
                stmt.setString(4, fish.getMeasurementUnit());
                stmt.setString(5, fish.getDiet());
                stmt.setString(6, String.join(",", fish.getHabitats()));
                stmt.setString(7, fish.getConservationStatus());
                stmt.setString(8, fish.getTag());
                int rows = stmt.executeUpdate();
                return rows > 0;
            } catch (SQLException e) {
                System.out.println("Error adding fish to database: " + e.getMessage());
                return false;
            }
        } else {
            mockFishList.add(fish);
            return true;
        }
    }

    /**
     * Retrieves all {@link Fish} records from the active data source.
     * <p>
     * If connected to a database, the results are fetched from the {@code fish_records}
     * table. Otherwise, the method returns a copy of the internal mock list.
     * </p>
     *
     * @return a list of all {@link Fish} objects; never {@code null}
     */
    public List<Fish> getAllFish() {
        if (useDatabase) {
            List<Fish> fishList = new ArrayList<>();
            String sql = "SELECT * FROM fish_records";
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {

                while (rs.next()) {
                    Fish fish = new Fish(
                            rs.getString("common_name"),
                            rs.getString("scientific_name"),
                            rs.getDouble("average_size"),
                            rs.getString("diet"),
                            Arrays.asList(rs.getString("habitats").split(",")),
                            rs.getString("conservation_status"),
                            rs.getString("tag")
                    );
                    fish.setMeasurementUnit(rs.getString("measurement_unit"));
                    fishList.add(fish);
                }
            } catch (SQLException e) {
                System.out.println("Error reading from database: " + e.getMessage());
            }
            return fishList;
        } else {
            return new ArrayList<>(mockFishList);
        }
    }

    /**
     * Finds a {@link Fish} by its unique tag.
     * <p>
     * In database mode, this runs a parameterized query against the
     * {@code fish_records} table. In mock mode, it searches the in-memory list.
     * </p>
     *
     * @param tag the tag of the {@link Fish} to find
     * @return the matching {@link Fish} object, or {@code null} if not found or if
     *         {@code tag} is {@code null} or empty
     */
    public Fish findFishByTag(String tag) {
        if (tag == null || tag.isEmpty()) return null;
        if (useDatabase) {
            String sql = "SELECT * FROM fish_records WHERE tag = ?";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, tag);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    Fish fish = new Fish(
                            rs.getString("common_name"),
                            rs.getString("scientific_name"),
                            rs.getDouble("average_size"),
                            rs.getString("diet"),
                            Arrays.asList(rs.getString("habitats").split(",")),
                            rs.getString("conservation_status"),
                            rs.getString("tag")
                    );
                    fish.setMeasurementUnit(rs.getString("measurement_unit"));
                    return fish;
                }
            } catch (SQLException e) {
                System.out.println("Error finding fish: " + e.getMessage());
            }
            return null;
        } else {
            return mockFishList.stream()
                    .filter(f -> f.getTag().equals(tag))
                    .findFirst()
                    .orElse(null);
        }
    }

    /**
     * Updates an existing {@link Fish} record identified by its previous tag.
     * <p>
     * This method supports changing the tag value. In database mode, the update
     * uses the old tag in the {@code WHERE} clause and applies all new values
     * from the {@code updatedFish} instance.
     * </p>
     *
     * @param updatedFish the {@link Fish} object containing the new values
     * @param oldTag      the original tag used to locate the existing record
     * @return {@code true} if the record was updated; {@code false} if the record
     *         was not found, validation failed, or an error occurred
     */
    public boolean updateFish(Fish updatedFish, String oldTag) {
        if (updatedFish == null || oldTag == null || oldTag.isEmpty()) return false;
        if (!validateFish(updatedFish)) return false;

        if (useDatabase) {
            String sql = """
                    UPDATE fish_records
                    SET common_name = ?, 
                        scientific_name = ?, 
                        average_size = ?, 
                        measurement_unit = ?, 
                        diet = ?, 
                        habitats = ?, 
                        conservation_status = ?, 
                        tag = ?
                    WHERE tag = ?
                    """;

            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, updatedFish.getCommonName());
                stmt.setString(2, updatedFish.getScientificName());
                stmt.setDouble(3, updatedFish.getAverageSize());
                stmt.setString(4, updatedFish.getMeasurementUnit());
                stmt.setString(5, updatedFish.getDiet());
                stmt.setString(6, String.join(",", updatedFish.getHabitats()));
                stmt.setString(7, updatedFish.getConservationStatus());
                stmt.setString(8, updatedFish.getTag());   // new tag
                stmt.setString(9, oldTag);                 // where old tag

                int rows = stmt.executeUpdate();
                return rows > 0;
            } catch (SQLException e) {
                System.out.println("Error updating fish: " + e.getMessage());
                return false;
            }
        }

        // Mock mode
        for (int i = 0; i < mockFishList.size(); i++) {
            if (mockFishList.get(i).getTag().equals(oldTag)) {
                mockFishList.set(i, updatedFish);
                return true;
            }
        }
        return false;
    }

    /**
     * Removes a {@link Fish} record by tag.
     *
     * @param tag the tag of the {@link Fish} to remove
     * @return {@code true} if a matching record was removed; {@code false} otherwise
     */
    public boolean removeFishByTag(String tag) {
        if (tag == null || tag.isEmpty()) return false;
        if (useDatabase) {
            String sql = "DELETE FROM fish_records WHERE tag = ?";
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.setString(1, tag);
                int rows = stmt.executeUpdate();
                return rows > 0;
            } catch (SQLException e) {
                System.out.println("Error deleting fish: " + e.getMessage());
                return false;
            }
        } else {
            return mockFishList.removeIf(f -> f.getTag().equals(tag));
        }
    }

    /**
     * Calculates the average fish size across all records.
     * <p>
     * This is the project's required custom mathematical feature. In mock mode,
     * it computes the average over the in-memory list; in database mode, it
     * delegates the calculation to SQLite using {@code AVG(average_size)}.
     * </p>
     *
     * @return the average size of all fish; {@code 0.0} if no records exist or
     *         if an error occurs
     */
    public double calculateAverageFishSize() {
        if (!useDatabase) {
            return mockFishList.stream()
                    .mapToDouble(Fish::getAverageSize)
                    .average()
                    .orElse(0.0);
        }
        String sql = "SELECT AVG(average_size) AS avg_size FROM fish_records";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            if (rs.next()) {
                return rs.getDouble("avg_size");
            }
        } catch (SQLException e) {
            System.out.println("Error calculating average size: " + e.getMessage());
        }
        return 0.0;
    }

    /**
     * Clears all {@link Fish} records from the mock list or database.
     * <p>
     * This is primarily used for testing, demo resets, or to quickly
     * reinitialize the dataset.
     * </p>
     *
     * @return {@code true} if records were cleared successfully; {@code false} if
     *         an error occurred in database mode
     */
    public boolean clearAll() {
        if (useDatabase) {
            try (Statement stmt = connection.createStatement()) {
                stmt.executeUpdate("DELETE FROM fish_records");
                return true;
            } catch (SQLException e) {
                System.out.println("Error clearing database: " + e.getMessage());
                return false;
            }
        } else {
            mockFishList.clear();
            return true;
        }
    }

    /**
     * Validates that a {@link Fish} object has proper data before inserting or updating.
     * <p>
     * This is a defensive check to protect the database and mock list from
     * invalid or incomplete records.
     * </p>
     *
     * @param fish the {@link Fish} object to validate
     * @return {@code true} if valid; {@code false} otherwise
     */
    private boolean validateFish(Fish fish) {
        if (fish.getCommonName() == null || fish.getCommonName().isEmpty()) {
            System.out.println("Validation Error: Common name cannot be empty.");
            return false;
        }
        if (fish.getScientificName() == null || fish.getScientificName().isEmpty()) {
            System.out.println("Validation Error: Scientific name cannot be empty.");
            return false;
        }
        if (fish.getAverageSize() <= 0) {
            System.out.println("Validation Error: Average size must be greater than 0.");
            return false;
        }
        if (fish.getTag() == null || fish.getTag().isEmpty()) {
            System.out.println("Validation Error: Tag cannot be empty.");
            return false;
        }
        return true;
    }

    /**
     * Indicates whether this DAO is currently using a SQLite database connection.
     *
     * @return {@code true} if operations target the database; {@code false} if
     *         the DAO is in mock (in-memory) mode
     */
    public boolean isUsingDatabase() {
        return useDatabase;
    }
}
