import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * RandomFunFactTest.java
 *
 * Unit test suite for the RandomFunFact class (Phase 4).
 *
 * Validates:
 * - Random fact generation and reshuffling behavior.
 * - Ensures uniqueness of facts within a cycle.
 * - Confirms integration with FishManager (average habitats, diversity).
 * - Verifies safe reinitialization and null-manager handling.
 * - Tests robustness over multiple calls.
 */
public class RandomFunFactTest {

    private FishManager manager;
    private FishDAO dao;

    @BeforeEach
    void setUp() {
        dao = new FishDAO();
        dao.connect("");   // Force mock (in-memory) mode
        dao.clearAll();

        dao.addFish(new Fish("Bass", "Micropterus", 12.0,
                "insects algae", List.of("Lake", "River"),
                "Least Concern", "001-00-0001"));
        dao.addFish(new Fish("Snook", "Centropomus", 20.0,
                "shrimp small fish", List.of("Estuary", "Mangrove"),
                "Near Threatened", "002-00-0002"));

        manager = new FishManager(dao);
        RandomFunFact.resetForTesting();
        RandomFunFact.initialize(manager);
    }

    // ---- Basic Functionality ----
    @Test
    void testGetRandomFactReturnsNonNullAndNotEmpty() {
        String fact = RandomFunFact.getRandomFact();
        assertNotNull(fact, "Random fun fact should not be null");
        assertFalse(fact.isBlank(), "Random fun fact should not be blank or empty");
    }

    // ---- Uniqueness per Cycle ----
    @Test
    void testNoDuplicateFactsInSingleCycle() {
        int totalFacts = RandomFunFact.getTotalFactCount();
        Set<String> seen = new HashSet<>();
        for (int i = 0; i < totalFacts; i++) {
            String fact = RandomFunFact.getRandomFact();
            // Strip out the random manager context so uniqueness only compares base fact
            String baseFact = fact.split("\\(On average")[0].trim();
            assertTrue(seen.add(baseFact),
                    "Duplicate base fact detected in a single cycle: " + baseFact);
        }
    }

    // ---- Reshuffling Behavior ----
    @Test
    void testReshufflesAfterAllFactsShown() {
        int totalFacts = RandomFunFact.getTotalFactCount();
        for (int i = 0; i < totalFacts; i++) {
            assertNotNull(RandomFunFact.getRandomFact(),
                    "Fact should exist during initial cycle");
        }
        // Trigger reshuffle
        String reshuffledFact = RandomFunFact.getRandomFact();
        assertNotNull(reshuffledFact, "Fact after reshuffle should not be null");
        assertFalse(reshuffledFact.isBlank(), "Fact after reshuffle should not be blank");
        assertEquals(1, RandomFunFact.getCurrentIndex(),
                "After reshuffle, currentIndex should reset to 1 after new fact retrieval");
    }

    // ---- Randomness Validation ----
    @Test
    void testRandomnessVariety() {
        String first = RandomFunFact.getRandomFact();
        boolean varied = false;
        for (int i = 0; i < 10; i++) {
            if (!RandomFunFact.getRandomFact().equals(first)) {
                varied = true;
                break;
            }
        }
        assertTrue(varied, "Expected variety in random facts after multiple calls");
    }

    // ---- Integration with FishManager (Average Habitats) ----
    @Test
    void testIntegrationWithFishManagerHabitats() {
        double avg = manager.calculateAverageHabitatsPerFish();
        assertEquals(2.0, avg, 0.01, "Average habitats per fish should be 2.0");
    }

    // ---- Integration with FishManager Contextual Fact ----
    @Test
    void testContextualFactMayIncludeAverageHabitats() {
        boolean foundContext = false;
        for (int i = 0; i < 100; i++) { // 100 tries should catch the 20% chance at least once
            String fact = RandomFunFact.getRandomFact();
            if (fact.contains("habitats per fish")) {
                foundContext = true;
                assertTrue(fact.contains("("), "Contextual fact should append in parentheses");
                break;
            }
        }
        assertTrue(foundContext, "At least one contextual fact with average habitats should eventually appear");
    }

    // ---- Integration with FishManager (Diversity) ----
    @Test
    void testIntegrationWithFishManagerDiversity() {
        String top = manager.getTopDiversityFish();
        assertTrue(top.contains("Snook"), "Snook should be the top diversity fish");
        assertTrue(top.contains("score"), "Output should include diversity score");
    }

    // ---- Robustness over Time ----
    @Test
    void testRobustnessAcrossManyCalls() {
        for (int i = 0; i < 200; i++) {
            String fact = RandomFunFact.getRandomFact();
            assertNotNull(fact, "Fact should never be null on iteration " + i);
            assertFalse(fact.isBlank(), "Fact should never be blank");
        }
    }

    // ---- Safe Re-Initialization ----
    @Test
    void testMultipleInitializationCallsSafe() {
        assertDoesNotThrow(() -> {
            RandomFunFact.initialize(manager);
            RandomFunFact.initialize(manager);
        }, "Reinitializing RandomFunFact should not cause errors");
    }

    // ---- Edge Case: Null Manager ----
    @Test
    void testInitializeWithNullManagerHandled() {
        assertDoesNotThrow(() -> RandomFunFact.initialize(null),
                "Initializing with null FishManager should not crash");
        RandomFunFact.resetForTesting();
        RandomFunFact.initialize(null);
        String fact = RandomFunFact.getRandomFact();
        assertNotNull(fact, "Random fact should still return with null manager");
    }

    // ---- Internal State ----
    @Test
    void testGetTotalFactCountAndCurrentIndex() {
        int total = RandomFunFact.getTotalFactCount();
        assertTrue(total >= 10, "Should have a reasonable number of stored facts");
        RandomFunFact.resetForTesting();
        assertEquals(0, RandomFunFact.getCurrentIndex(),
                "Reset should clear index to zero");
    }
}
