import javafx.animation.FadeTransition;
import javafx.application.Platform;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.control.cell.CheckBoxTableCell;
import javafx.scene.layout.*;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Builds and manages the "Manage Fish" tab for the
 * Florida Native Fish Database Management System (DMS).
 *
 * Features:
 * <ul>
 *     <li>Full fish table view with selection, search, and bulk operations.</li>
 *     <li>Single and bulk edit, delete with undo support, and duplicate checks.</li>
 *     <li>Expandable table area with smooth height animation.</li>
 * </ul>
 *
 * Design goal:
 * <p>Create a structured data-management console interface that is professional,
 * consistent, and visually stable under the {@link NatureTheme} palette.</p>
 */
@SuppressWarnings("unchecked")
public class ManageFishLogicGUI {

    /** Underlying fish dataset reference (shared with FishManager). */
    private final List<Fish> fishList;

    /** Handles fish-related calculations and metrics. */
    private final FishManager fishManager;

    /** Handles all database persistence (shared instance from main app). */
    private final FishDAO fishDAO;

    /** Table data model used for display and selection. */
    private final ObservableList<FishRow> tableData = FXCollections.observableArrayList();

    /** Main table and layout containers. */
    private TableView<FishRow> fishTable;
    private VBox rootLayout;

    /**
     * Creates a new management console controller for fish records.
     *
     * @param fishList    reference to the shared list of {@link Fish} objects
     * @param fishManager manager responsible for fish data logic and analytics
     * @param fishDAO     shared data-access object used to persist and load fish data
     */
    public ManageFishLogicGUI(List<Fish> fishList, FishManager fishManager, FishDAO fishDAO) {
        this.fishList = fishList;
        this.fishManager = fishManager;
        this.fishDAO = fishDAO;
    }

    //---- TAB CONSTRUCTION ----

    /**
     * Builds the "Manage Fish" tab and initializes the table, toolbar,
     * and associated interactions.
     *
     * <p>The returned tab exposes:</p>
     * <ul>
     *     <li>Search by tag</li>
     *     <li>Selection and bulk selection controls</li>
     *     <li>Edit, bulk edit, delete with undo, and duplicate checks</li>
     *     <li>Expandable fish table view</li>
     * </ul>
     *
     * @return a fully configured {@link Tab} instance for managing fish records
     */
    public Tab buildTab() {
        Tab tab = new Tab("Manage Fish");
        tab.setClosable(false);

        rootLayout = new VBox(12);
        rootLayout.setPadding(new Insets(16));
        NatureTheme.applyBackground(rootLayout);

        Label title = new Label("Florida Native Fish Database — Management Console");
        title.setFont(Font.font("Segoe UI", FontWeight.BOLD, 18));
        NatureTheme.styleTitle(title);

        //---- Toolbar setup ----
        HBox topBar = new HBox(10);
        topBar.setAlignment(Pos.CENTER_LEFT);
        NatureTheme.styleToolbar(topBar);

        HBox rightGroup = new HBox(8);
        rightGroup.setAlignment(Pos.CENTER_RIGHT);

        TextField tagField = new TextField();
        tagField.setPromptText("Tag: 000-00-0000");
        tagField.setPrefColumnCount(16);
        tagField.setTooltip(new Tooltip("Search by exact Tag"));

        Button searchBtn = new Button("Search");
        Button checkBtn = new Button("Check Selected");
        Button editBtn = new Button("Edit / Bulk Edit");
        Button deleteBtn = new Button("Delete");
        Button refreshBtn = new Button("Refresh");
        Button dupBtn = new Button("Duplicate Check");
        Button toggleSelectBtn = new Button("Select All");

        searchBtn.setTooltip(new Tooltip("Search fish by Tag"));
        checkBtn.setTooltip(new Tooltip("Show selected fish summary"));
        editBtn.setTooltip(new Tooltip("Edit one or multiple fish"));
        deleteBtn.setTooltip(new Tooltip("Delete selected fish (with Undo)"));
        refreshBtn.setTooltip(new Tooltip("Reload the full dataset"));
        dupBtn.setTooltip(new Tooltip("Find duplicate/missing tags"));
        toggleSelectBtn.setTooltip(new Tooltip("Select or Deselect all rows"));

        NatureTheme.styleSecondary(searchBtn);
        NatureTheme.styleSecondary(checkBtn);
        NatureTheme.styleSecondary(editBtn);
        NatureTheme.stylePrimary(deleteBtn);
        NatureTheme.styleSecondary(refreshBtn);
        NatureTheme.styleSecondary(dupBtn);
        NatureTheme.styleSecondary(toggleSelectBtn);

        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);

        topBar.getChildren().addAll(
                new Label("Tag:"), tagField,
                searchBtn, checkBtn, editBtn, deleteBtn, refreshBtn, dupBtn,
                spacer, rightGroup
        );
        rightGroup.getChildren().add(toggleSelectBtn);

        // SEARCH
        searchBtn.setOnAction(e -> {
            String tag = tagField.getText().trim();
            if (tag.isEmpty()) {
                showAlert("Search", "Please enter a tag to search.");
                return;
            }
            Optional<FishRow> found = tableData.stream()
                    .filter(r -> r.getTag().equalsIgnoreCase(tag))
                    .findFirst();
            if (found.isPresent()) {
                fishTable.getSelectionModel().select(found.get());
                fishTable.scrollTo(found.get());
                showAlert("Search Result", "Found fish with tag: " + tag);
            } else {
                showAlert("Search", "No fish found with tag: " + tag);
            }
        });

        // CHECK SELECTED
        checkBtn.setOnAction(e -> {
            var selected = tableData.stream().filter(FishRow::isSelected).toList();

            if (selected.isEmpty()) {
                showAlert("Check Selected", "No fish selected.");
                return;
            }
            StringBuilder summary = new StringBuilder("Selected Fish:\n\n");
            for (FishRow row : selected) {
                summary.append("- ")
                        .append(row.commonNameProperty().get())
                        .append(" (Tag: ").append(row.getTag()).append(")\n");
            }

            showAlert("Selected Summary", summary.toString());
        });

        // EDIT / BULK EDIT
        editBtn.setOnAction(e -> {
            var selected = tableData.stream().filter(FishRow::isSelected).toList();
            if (selected.isEmpty()) {
                showAlert("Edit", "No fish selected.");
                return;
            }
            if (selected.size() == 1) {
                editSingleFish(selected.get(0)); // single edit (can change tag)
            } else {
                bulkEditSelectedFish(selected);  // bulk edit (no tag changes)
            }
        });

        // DELETE
        deleteBtn.setOnAction(e -> deleteSelected(toggleSelectBtn));

        // REFRESH
        refreshBtn.setOnAction(e -> refresh());

        // DUPLICATES
        dupBtn.setOnAction(e -> checkDuplicatesAndMissing());

        // SELECT / DESELECT ALL
        toggleSelectBtn.setOnAction(e -> {
            boolean selectAll = toggleSelectBtn.getText().equals("Select All");
            for (FishRow row : tableData)
                row.selectedProperty().set(selectAll);
            updateToggleButtonState(toggleSelectBtn);
        });

        // TABLE SETUP
        fishTable = new TableView<>(tableData);
        fishTable.setEditable(true);
        fishTable.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        NatureTheme.styleTable(fishTable);

        TableColumn<FishRow, Boolean> selectCol = new TableColumn<>("Select");
        selectCol.setMinWidth(72);
        selectCol.setCellValueFactory(c -> c.getValue().selectedProperty());
        selectCol.setCellFactory(CheckBoxTableCell.forTableColumn(selectCol));
        selectCol.setEditable(true);

        TableColumn<FishRow, String> nameCol = new TableColumn<>("Common Name");
        nameCol.setCellValueFactory(c -> c.getValue().commonNameProperty());

        TableColumn<FishRow, String> sciCol = new TableColumn<>("Scientific Name");
        sciCol.setCellValueFactory(c -> c.getValue().scientificNameProperty());

        TableColumn<FishRow, String> sizeCol = new TableColumn<>("Size (unit)");
        sizeCol.setCellValueFactory(c -> c.getValue().sizeProperty());

        TableColumn<FishRow, String> dietCol = new TableColumn<>("Diet");
        dietCol.setCellValueFactory(c -> c.getValue().dietProperty());

        TableColumn<FishRow, String> habitatCol = new TableColumn<>("Habitats");
        habitatCol.setCellValueFactory(c -> c.getValue().habitatProperty());

        TableColumn<FishRow, String> statusCol = new TableColumn<>("Status");
        statusCol.setCellValueFactory(c -> c.getValue().statusProperty());

        TableColumn<FishRow, String> tagCol = new TableColumn<>("Tag");
        tagCol.setCellValueFactory(c -> c.getValue().tagProperty());

        fishTable.getColumns().addAll(
                selectCol, nameCol, sciCol, sizeCol, dietCol, habitatCol, statusCol, tagCol
        );
        VBox tableCard = new VBox(fishTable);
        NatureTheme.styleCard(tableCard);
        tableCard.setPadding(new Insets(8));

        Button expandBtn = new Button("Expand ↓");
        NatureTheme.styleSecondary(expandBtn);
        expandBtn.setMaxWidth(Double.MAX_VALUE);
        expandBtn.setAlignment(Pos.CENTER);

        final boolean[] expanded = {false};
        expandBtn.setOnAction(e -> {
            if (!expanded[0]) {
                animateHeight(fishTable, 1100);
                expandBtn.setText("Collapse ↑");
                expanded[0] = true;
            } else {
                animateHeight(fishTable, 400);
                expandBtn.setText("Expand ↓");
                expanded[0] = false;
            }
        });

        fishTable.setRowFactory(tv -> {
            TableRow<FishRow> row = new TableRow<>();
            row.setOnMouseClicked(event -> {
                if (row.isEmpty()) return;
                FishRow data = row.getItem();
                int rowIndex = row.getIndex();
                var selectionModel = fishTable.getSelectionModel();
                Integer anchorIndex = (Integer) fishTable.getProperties().get("anchorIndex");

                if (event.getClickCount() == 2) {
                    boolean newVal = !data.isSelected();
                    data.selectedProperty().set(newVal);
                    if (newVal) selectionModel.select(rowIndex);
                    else selectionModel.clearSelection(rowIndex);
                    fishTable.getProperties().put("anchorIndex", rowIndex);
                    updateToggleButtonState(toggleSelectBtn);
                    return;
                }

                if (event.isShiftDown() && anchorIndex != null) {
                    int start = Math.min(anchorIndex, rowIndex);
                    int end = Math.max(anchorIndex, rowIndex);
                    selectionModel.clearSelection();
                    for (int i = start; i <= end; i++) {
                        FishRow r = fishTable.getItems().get(i);
                        r.selectedProperty().set(true);
                        selectionModel.select(i);
                    }
                    updateToggleButtonState(toggleSelectBtn);
                    return;
                }

                if (event.isControlDown() || event.isMetaDown()) {
                    boolean newVal = !data.isSelected();
                    data.selectedProperty().set(newVal);
                    if (newVal) selectionModel.select(rowIndex);
                    else selectionModel.clearSelection(rowIndex);
                    fishTable.getProperties().put("anchorIndex", rowIndex);
                    updateToggleButtonState(toggleSelectBtn);
                    return;
                }

                boolean newVal = !data.isSelected();
                data.selectedProperty().set(newVal);
                selectionModel.clearSelection();
                if (newVal) selectionModel.select(rowIndex);
                fishTable.getProperties().put("anchorIndex", rowIndex);
                updateToggleButtonState(toggleSelectBtn);
            });
            return row;
        });

        fishTable.setOnKeyPressed(event -> {
            if (event.getCode() == javafx.scene.input.KeyCode.SPACE) {
                var selectionModel = fishTable.getSelectionModel();
                ObservableList<FishRow> selectedRows = selectionModel.getSelectedItems();

                if (!selectedRows.isEmpty()) {
                    boolean allSelected = selectedRows.stream().allMatch(FishRow::isSelected);
                    boolean newVal = !allSelected;
                    for (FishRow row : selectedRows) {
                        row.selectedProperty().set(newVal);
                    }
                } else {
                    FishRow focused = fishTable.getFocusModel().getFocusedItem();
                    if (focused != null) focused.selectedProperty().set(!focused.isSelected());
                }

                updateToggleButtonState(toggleSelectBtn);
                pulseButton(toggleSelectBtn);
                event.consume();
            }
        });

        refresh();
        tableData.addListener((ListChangeListener<FishRow>) c -> updateToggleButtonState(toggleSelectBtn));

        rootLayout.getChildren().addAll(title, topBar, tableCard, expandBtn);
        tab.setContent(rootLayout);
        return tab;
    }

    // ---- CORE ACTIONS ----

    /**
     * Reloads the table data from the backing data source.
     *
     * <p>This method:</p>
     * <ul>
     *     <li>Fetches the latest records from {@link FishDAO} (if available).</li>
     *     <li>Updates the shared {@link #fishList} and the {@link #tableData} model.</li>
     *     <li>Refreshes the JavaFX table view.</li>
     * </ul>
     */
    public void refresh() {
        tableData.clear();

        if (fishDAO != null) {

            List<Fish> latestData = fishDAO.getAllFish();

            fishList.clear();
            if (latestData != null) {
                fishList.addAll(latestData);
            }
        }

        for (Fish f : fishList) {
            tableData.add(new FishRow(f));
        }

        fishTable.refresh();
    }

    /**
     * Deletes all currently selected rows, offers a short undo window, and
     * persists deletions via {@link FishDAO}.
     *
     * @param toggleSelectBtn the "Select All" / "Deselect All" button used to update label state
     */
    private void deleteSelected(Button toggleSelectBtn) {
        var selected = tableData.stream().filter(FishRow::isSelected).toList();
        if (selected.isEmpty()) {
            showAlert("Delete", "No fish selected for deletion.");
            return;
        }
        Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);
        confirm.setTitle("Confirm Deletion");
        confirm.setHeaderText("Delete selected records?");
        confirm.setContentText("This will remove " + selected.size() + " record(s). Undo will be available.");
        NatureTheme.styleAlert(confirm);

        Optional<ButtonType> res = confirm.showAndWait();
        if (res.isEmpty() || res.get() != ButtonType.OK) return;

        List<Fish> backup = selected.stream()
                .map(r -> fishList.stream()
                        .filter(f -> f.getTag() != null && f.getTag().equals(r.getTag()))
                        .findFirst().orElse(null))
                .filter(Objects::nonNull)
                .toList();

        for (FishRow r : selected) {
            String tag = r.getTag();
            fishList.removeIf(f -> f.getTag() != null && f.getTag().equals(tag));
            fishDAO.removeFishByTag(tag);
        }

        refresh();
        updateToggleButtonState(toggleSelectBtn);

        Button undoBtn = new Button("Undo Delete (" + backup.size() + ")");
        NatureTheme.styleSecondary(undoBtn);
        rootLayout.getChildren().add(1, undoBtn);

        undoBtn.setOnAction(ev -> {
            for (Fish f : backup) {
                fishDAO.addFish(f);
            }
            refresh();

            rootLayout.getChildren().remove(undoBtn);
            showAlert("Undo Complete", "Restored " + backup.size() + " record(s).");
        });

        new Thread(() -> {
            try {
                Thread.sleep(10000);
                Platform.runLater(() -> rootLayout.getChildren().remove(undoBtn));
            } catch (InterruptedException ignored) {}
        }).start();

        showAlert("Deleted", "Removed " + backup.size() + " record(s). Undo available for 10 seconds.");
    }

    // SINGLE EDIT (supports tag change)

    /**
     * Opens a dialog to edit a single fish row, allowing full modification
     * of its properties (including tag) and persisting changes to the database.
     *
     * @param row the {@link FishRow} corresponding to the fish record to edit
     */
    private void editSingleFish(FishRow row) {

        Fish target = fishList.stream()
                .filter(f -> f.getTag() != null && f.getTag().equals(row.getTag()))
                .findFirst().orElse(null);

        if (target == null) {
            showError("Edit Error", "Selected fish could not be found.");
            return;
        }

        String oldTag = target.getTag();

        Dialog<Fish> dialog = new Dialog<>();
        dialog.setTitle("Edit Fish — " + oldTag);
        DialogPane dp = dialog.getDialogPane();
        dp.setPrefWidth(460);
        dp.setStyle("-fx-background-color: #F1F8E9;");
        safeHeaderStyle(dp);

        GridPane grid = new GridPane();
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new Insets(15));

        TextField nameField = new TextField(target.getCommonName());
        TextField sciField = new TextField(target.getScientificName());
        TextField sizeField = new TextField(String.valueOf(target.getAverageSize()));
        ComboBox<String> unitBox = new ComboBox<>(FXCollections.observableArrayList(
                "mm", "cm", "m", "in", "ft", "yd"
        ));
        unitBox.setValue(target.getMeasurementUnit());

        TextField dietField = new TextField(target.getDiet());
        TextField habitatField = new TextField(
                target.getHabitats() != null ? String.join(", ", target.getHabitats()) : ""
        );

        ComboBox<String> statusBox = new ComboBox<>(FXCollections.observableArrayList(
                "Least Concern", "Near Threatened", "Vulnerable", "Endangered",
                "Critically Endangered", "Extinct in the Wild", "Extinct"
        ));
        statusBox.setValue(target.getConservationStatus());

        TextField tagField = new TextField(oldTag);

        // Force 000-00-0000 style as the user types
        enforceTagMask(tagField);

        grid.add(new Label("Common Name:"), 0, 0); grid.add(nameField, 1, 0);
        grid.add(new Label("Scientific Name:"), 0, 1); grid.add(sciField, 1, 1);
        grid.add(new Label("Size:"), 0, 2); grid.add(sizeField, 1, 2); grid.add(unitBox, 2, 2);
        grid.add(new Label("Diet:"), 0, 3); grid.add(dietField, 1, 3);
        grid.add(new Label("Habitats:"), 0, 4); grid.add(habitatField, 1, 4);
        grid.add(new Label("Status:"), 0, 5); grid.add(statusBox, 1, 5);
        grid.add(new Label("Tag:"), 0, 6); grid.add(tagField, 1, 6);

        dp.setContent(grid);

        ButtonType saveBtn = new ButtonType("Save", ButtonBar.ButtonData.OK_DONE);
        dp.getButtonTypes().addAll(saveBtn, ButtonType.CANCEL);

        // Validation so dialog does not close on invalid input
        Button saveButtonNode = (Button) dp.lookupButton(saveBtn);
        saveButtonNode.addEventFilter(javafx.event.ActionEvent.ACTION, event -> {
            String common = nameField.getText().trim();
            String sci    = sciField.getText().trim();
            String sizeText = sizeField.getText().trim();

            if (common.matches(".*\\d.*")) {
                showAlert("Validation Error", "Common name cannot contain numbers.");
                event.consume();
                return;
            }

            if (sci.matches(".*\\d.*")) {
                showAlert("Validation Error", "Scientific name cannot contain numbers.");
                event.consume();
                return;
            }

            if (sizeText.isBlank()) {
                showAlert("Validation Error", "Average size must be a valid number.");
                event.consume();
                return;
            }
            try {
                Double.parseDouble(sizeText);
            } catch (NumberFormatException ex) {
                showAlert("Validation Error", "Average size must be a valid number.");
                event.consume();
            }
        });

        // Now resultConverter assumes values are valid if Save got this far
        dialog.setResultConverter(btn -> {
            if (btn == saveBtn) {
                String newTag = tagField.getText().trim();
                try {
                    target.setCommonName(nameField.getText());
                    target.setScientificName(sciField.getText());
                    target.setAverageSize(Double.parseDouble(sizeField.getText()));
                    target.setMeasurementUnit(unitBox.getValue());
                    target.setDiet(dietField.getText());

                    if (!habitatField.getText().isBlank()) {
                        target.setHabitats(List.of(habitatField.getText().split("\\s*,\\s*")));
                    }

                    target.setConservationStatus(statusBox.getValue());
                    target.setTag(newTag);

                    // Use OLD TAG in WHERE clause
                    fishDAO.updateFish(target, oldTag);

                    refresh();
                    return target;

                } catch (Exception ex) {
                    showError("Update Error", "Failed to update fish:\n" + ex.getMessage());
                }
            }
            return null;
        });

        dialog.showAndWait();
    }

    /**
     * Shows an error dialog with NatureTheme styling.
     *
     * @param title   dialog title text
     * @param message dialog content text describing the error
     */
    private void showError(String title, String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        NatureTheme.styleAlert(alert);
        alert.showAndWait();
    }

    /**
     * Shows a warning dialog with "Continue" / "Cancel" options.
     *
     * @param title   dialog title text
     * @param message dialog body text
     * @return {@code true} if the user chose to continue; {@code false} if cancelled
     */
    private boolean showWarningContinue(String title, String message) {
        Alert alert = new Alert(Alert.AlertType.WARNING);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);

        ButtonType yes = new ButtonType("Continue");
        ButtonType no = new ButtonType("Cancel", ButtonBar.ButtonData.CANCEL_CLOSE);

        alert.getButtonTypes().setAll(yes, no);
        NatureTheme.styleAlert(alert);

        Optional<ButtonType> result = alert.showAndWait();
        return result.isPresent() && result.get() == yes;
    }

    /**
     * Forces text in a {@link TextField} into {@code 000-00-0000} tag format as the user types.
     *
     * <p>Non-digit characters are stripped and dashes are inserted at positions 3 and 6.</p>
     *
     * @param tagField the {@link TextField} whose content should be formatted as a tag
     */
    public static void enforceTagMask(TextField tagField) {

        tagField.textProperty().addListener((obs, oldValue, newValue) -> {

            String digits = newValue.replaceAll("[^0-9]", "");

            if (digits.length() > 9)
                digits = digits.substring(0, 9);

            StringBuilder formatted = new StringBuilder();

            for (int i = 0; i < digits.length(); i++) {
                formatted.append(digits.charAt(i));
                if (i == 2 || i == 4) formatted.append("-");
            }

            if (!formatted.toString().equals(newValue)) {
                tagField.setText(formatted.toString());
            }
        });
    }

    // ---------------------------------------------------------
    // BULK EDIT (NO TAG CHANGES ALLOWED)
    // ---------------------------------------------------------

    /**
     * Performs a bulk edit operation on multiple selected rows.
     *
     * <p>Only non-empty fields in the dialog are applied to each selected record,
     * and tags remain unchanged. An undo snapshot is captured prior to applying changes.</p>
     *
     * @param selected list of {@link FishRow} items to be updated
     */
    private void bulkEditSelectedFish(List<FishRow> selected) {

        // Snapshot BEFORE edits for Undo
        Map<String, FishSnapshot> before = new HashMap<>();
        for (FishRow r : selected) {
            Fish f = fishList.stream()
                    .filter(x -> x.getTag() != null && x.getTag().equals(r.getTag()))
                    .findFirst().orElse(null);
            if (f != null) before.put(f.getTag(), FishSnapshot.of(f));
        }

        Dialog<Void> dialog = new Dialog<>();
        dialog.setTitle("Bulk Edit — " + selected.size() + " record(s)");
        DialogPane dp = dialog.getDialogPane();
        dp.setPrefWidth(520);
        dp.setStyle("-fx-background-color: #F1F8E9;");
        safeHeaderStyle(dp);

        GridPane grid = new GridPane();
        grid.setPadding(new Insets(15));
        grid.setHgap(10);
        grid.setVgap(10);

        TextField nameField = new TextField();
        TextField sciField = new TextField();
        TextField sizeField = new TextField();

        ComboBox<String> unitBox = new ComboBox<>(FXCollections.observableArrayList(
                "mm", "cm", "m", "in", "ft", "yd"));
        unitBox.setPromptText("keep");

        TextField dietField = new TextField();
        TextField habitatField = new TextField();

        ComboBox<String> statusBox = new ComboBox<>(FXCollections.observableArrayList(
                "Least Concern", "Near Threatened", "Vulnerable", "Endangered",
                "Critically Endangered", "Extinct in the Wild", "Extinct"));
        statusBox.setPromptText("keep");

        grid.add(new Label("Common Name:"), 0, 0);
        grid.add(nameField, 1, 0);
        grid.add(new Label("Scientific Name:"), 0, 1);
        grid.add(sciField, 1, 1);
        grid.add(new Label("Size:"), 0, 2);
        grid.add(sizeField, 1, 2);
        grid.add(unitBox, 2, 2);
        grid.add(new Label("Diet:"), 0, 3);
        grid.add(dietField, 1, 3);
        grid.add(new Label("Habitats:"), 0, 4);
        grid.add(habitatField, 1, 4);
        grid.add(new Label("Status:"), 0, 5);
        grid.add(statusBox, 1, 5);

        dp.setContent(grid);

        ButtonType applyBtn = new ButtonType("Apply to All", ButtonBar.ButtonData.OK_DONE);
        dp.getButtonTypes().addAll(applyBtn, ButtonType.CANCEL);

        // Validation runs before the dialog closes
        Button applyButtonNode = (Button) dp.lookupButton(applyBtn);
        applyButtonNode.addEventFilter(javafx.event.ActionEvent.ACTION, event -> {

            String common = nameField.getText().trim();
            String sci = sciField.getText().trim();
            String sizeText = sizeField.getText().trim();

            // Common name cannot contain numbers
            if (!common.isBlank() && common.matches(".*\\d.*")) {
                showAlert("Validation Error", "Common name cannot contain numbers.");
                event.consume();
                return;
            }

            // Scientific name cannot contain numbers
            if (!sci.isBlank() && sci.matches(".*\\d.*")) {
                showAlert("Validation Error", "Scientific name cannot contain numbers.");
                event.consume();
                return;
            }

            // Average size must be a valid number (if provided)
            if (!sizeText.isBlank()) {
                try {
                    Double.parseDouble(sizeText);
                } catch (NumberFormatException ex) {
                    showAlert("Validation Error", "Average size must be a valid number.");
                    event.consume();
                }
            }
        });

        dialog.setResultConverter(btn -> {

            if (btn == applyBtn) {

                Alert confirm = new Alert(Alert.AlertType.CONFIRMATION);
                confirm.setTitle("Confirm Bulk Edit");
                confirm.setHeaderText("Apply changes to " + selected.size() + " record(s)?");
                confirm.setContentText("Only non-empty fields will be updated.");
                NatureTheme.styleAlert(confirm);

                confirm.showAndWait().ifPresent(choice -> {
                    if (choice == ButtonType.OK) {

                        for (FishRow row : selected) {

                            Fish target = fishList.stream()
                                    .filter(f -> f.getTag() != null && f.getTag().equals(row.getTag()))
                                    .findFirst().orElse(null);

                            if (target == null) continue;

                            String tag = target.getTag(); // tag does not change

                            // Apply changes only if fields are not empty
                            if (!nameField.getText().isBlank())
                                target.setCommonName(nameField.getText());

                            if (!sciField.getText().isBlank())
                                target.setScientificName(sciField.getText());

                            if (!sizeField.getText().isBlank()) {
                                // safe now because validation already checked it is numeric
                                target.setAverageSize(Double.parseDouble(sizeField.getText()));
                            }

                            if (unitBox.getValue() != null)
                                target.setMeasurementUnit(unitBox.getValue());

                            if (!dietField.getText().isBlank())
                                target.setDiet(dietField.getText());

                            if (!habitatField.getText().isBlank())
                                target.setHabitats(List.of(habitatField.getText().split("\\s*,\\s*")));

                            if (statusBox.getValue() != null && !statusBox.getValue().isBlank())
                                target.setConservationStatus(statusBox.getValue());

                            // Push to DB
                            fishDAO.updateFish(target, tag);
                        }

                        refresh();
                        showAlert("Bulk Edit Complete",
                                "Updated " + selected.size() + " record(s).");

                        // UNDO BUTTON
                        Button undoBtn = new Button("Undo Bulk Edit (" + before.size() + ")");
                        NatureTheme.styleSecondary(undoBtn);
                        rootLayout.getChildren().add(1, undoBtn);

                        undoBtn.setOnAction(evv -> {
                            for (String tag : before.keySet()) {
                                FishSnapshot snap = before.get(tag);

                                Fish target = fishList.stream()
                                        .filter(f -> f.getTag() != null && f.getTag().equals(tag))
                                        .findFirst().orElse(null);

                                if (target != null) snap.applyTo(target);

                                // Optionally push undo to DB:
                                // fishDAO.updateFish(target, tag);
                            }
                            refresh();
                            rootLayout.getChildren().remove(undoBtn);
                            showAlert("Undo Complete",
                                    "Restored " + before.size() + " fish.");
                        });

                        // Auto-remove after 10 seconds
                        new Thread(() -> {
                            try {
                                Thread.sleep(10000);
                            } catch (Exception ignored) {
                            }
                            Platform.runLater(() -> rootLayout.getChildren().remove(undoBtn));
                        }).start();
                    }
                });
            }

            return null;
        });

        dialog.showAndWait();
    }

    /**
     * Checks for duplicate and missing tags within the dataset and displays
     * a formatted integrity report.
     *
     * <p>The report lists:</p>
     * <ul>
     *     <li>Tags that appear more than once, with counts.</li>
     *     <li>Records that have null or blank tags.</li>
     * </ul>
     */
    private void checkDuplicatesAndMissing() {

        // Always fetch fresh data from DB (or mock)
        List<Fish> latest = fishDAO.getAllFish();
        if (latest == null) latest = fishList; // fallback

        Map<String, Long> dupes = latest.stream()
                .collect(Collectors.groupingBy(Fish::getTag, Collectors.counting()));

        List<String> duplicateTags = dupes.entrySet().stream()
                .filter(e -> e.getValue() > 1)
                .map(e -> e.getKey() + " (" + e.getValue() + "×)")
                .toList();

        List<String> missingTags = latest.stream()
                .filter(f -> f.getTag() == null || f.getTag().isBlank())
                .map(Fish::getCommonName)
                .toList();

        StringBuilder result = new StringBuilder();
        if (!duplicateTags.isEmpty())
            result.append("Duplicates:\n")
                    .append(String.join("\n", duplicateTags))
                    .append("\n\n");

        if (!missingTags.isEmpty())
            result.append("Missing tags on:\n")
                    .append(String.join(", ", missingTags))
                    .append("\n");

        if (result.isEmpty())
            result.append("All tags are unique and present.");

        showAlert("Data Integrity Check", result.toString());
    }

    //---- SUPPORT UTILITIES ----

    /**
     * Updates the "Select All" button text based on table state.
     * <p>If all rows are selected, the label becomes "Deselect All";
     * otherwise, it remains "Select All".</p>
     *
     * @param toggleSelectBtn the button that toggles select/deselect all rows
     */
    private void updateToggleButtonState(Button toggleSelectBtn) {
        if (toggleSelectBtn == null) return;
        boolean allChecked = !tableData.isEmpty() && tableData.stream().allMatch(FishRow::isSelected);
        toggleSelectBtn.setText(allChecked ? "Deselect All" : "Select All");
    }

    /**
     * Simple visual pulse animation for highlighting user actions on a button.
     *
     * @param button the button to animate with a short fade transition
     */
    private void pulseButton(Button button) {
        FadeTransition ft = new FadeTransition(Duration.millis(140), button);
        ft.setFromValue(1.0);
        ft.setToValue(0.65);
        ft.setCycleCount(2);
        ft.setAutoReverse(true);
        ft.play();
    }

    /**
     * Displays a standard informational alert dialog styled under {@link NatureTheme}.
     *
     * @param title dialog title text
     * @param msg   message body to display to the user
     */
    private void showAlert(String title, String msg) {
        Alert a = new Alert(Alert.AlertType.INFORMATION);
        a.setTitle(title);
        a.setHeaderText(null);
        a.setContentText(msg);
        NatureTheme.styleAlert(a);
        a.showAndWait();
    }

    //---- DATA WRAPPERS ----

    /**
     * Represents a row in the fish management table.
     *
     * <p>Wraps a {@link Fish} instance into observable JavaFX properties
     * for binding and display in the {@link TableView}.</p>
     */
    public static class FishRow {
        private final SimpleBooleanProperty selected = new SimpleBooleanProperty(false);
        private final SimpleStringProperty commonName;
        private final SimpleStringProperty scientificName;
        private final SimpleStringProperty size;
        private final SimpleStringProperty diet;
        private final SimpleStringProperty habitat;
        private final SimpleStringProperty status;
        private final SimpleStringProperty tag;

        /**
         * Constructs a display row from a {@link Fish} object.
         * Null or blank values are converted into placeholder symbols where appropriate.
         *
         * @param f the {@link Fish} instance to wrap into table-friendly properties
         */
        public FishRow(Fish f) {
            this.commonName = new SimpleStringProperty(f.getCommonName());
            this.scientificName = new SimpleStringProperty(f.getScientificName());
            String unit = (f.getMeasurementUnit() != null) ? f.getMeasurementUnit() : "in";
            this.size = new SimpleStringProperty(f.getAverageSize() + " " + unit);
            this.diet = new SimpleStringProperty(
                    f.getDiet() != null && !f.getDiet().isBlank() ? f.getDiet() : "—"
            );
            this.habitat = new SimpleStringProperty(
                    (f.getHabitats() != null && !f.getHabitats().isEmpty())
                            ? String.join(", ", f.getHabitats())
                            : "—"
            );
            this.status = new SimpleStringProperty(
                    f.getConservationStatus() != null && !f.getConservationStatus().isBlank()
                            ? f.getConservationStatus()
                            : "—"
            );
            this.tag = new SimpleStringProperty(f.getTag());
        }

        /**
         * Indicates whether this row is marked as selected.
         *
         * @return {@code true} if the row is selected; otherwise {@code false}
         */
        public boolean isSelected() {
            return selected.get();
        }

        /**
         * Exposes the selection flag as an observable property for JavaFX bindings.
         *
         * @return the {@link SimpleBooleanProperty} tracking selection state
         */
        public SimpleBooleanProperty selectedProperty() {
            return selected;
        }

        /**
         * Exposes the common name as an observable property.
         *
         * @return the {@link SimpleStringProperty} for the common name
         */
        public SimpleStringProperty commonNameProperty() {
            return commonName;
        }

        /**
         * Exposes the scientific name as an observable property.
         *
         * @return the {@link SimpleStringProperty} for the scientific name
         */
        public SimpleStringProperty scientificNameProperty() {
            return scientificName;
        }

        /**
         * Exposes the size-with-unit string as an observable property.
         *
         * @return the {@link SimpleStringProperty} representing size and unit
         */
        public SimpleStringProperty sizeProperty() {
            return size;
        }

        /**
         * Exposes the diet description as an observable property.
         *
         * @return the {@link SimpleStringProperty} representing the diet
         */
        public SimpleStringProperty dietProperty() {
            return diet;
        }

        /**
         * Exposes the habitat description as an observable property.
         *
         * @return the {@link SimpleStringProperty} representing habitats
         */
        public SimpleStringProperty habitatProperty() {
            return habitat;
        }

        /**
         * Exposes the conservation status as an observable property.
         *
         * @return the {@link SimpleStringProperty} representing the status
         */
        public SimpleStringProperty statusProperty() {
            return status;
        }

        /**
         * Exposes the tag as an observable property.
         *
         * @return the {@link SimpleStringProperty} representing the tag
         */
        public SimpleStringProperty tagProperty() {
            return tag;
        }

        /**
         * Returns the raw tag string for this row.
         *
         * @return the tag text, or {@code null} if no tag is set
         */
        public String getTag() {
            return tag.get();
        }
    }

    /**
     * Snapshot of a {@link Fish} object’s state for undo functionality.
     * Used when bulk editing or restoring previous values.
     */
    private static class FishSnapshot {
        String commonName;
        String scientificName;
        double averageSize;
        String measurementUnit;
        String diet;
        List<String> habitats;
        String conservationStatus;

        /**
         * Creates a snapshot copy from the provided {@link Fish} object.
         *
         * @param f the source fish whose state should be captured
         * @return a new {@code FishSnapshot} holding the fish's current values
         */
        static FishSnapshot of(Fish f) {
            FishSnapshot s = new FishSnapshot();
            s.commonName = f.getCommonName();
            s.scientificName = f.getScientificName();
            s.averageSize = f.getAverageSize();
            s.measurementUnit = f.getMeasurementUnit();
            s.diet = f.getDiet();
            s.habitats = new ArrayList<>(f.getHabitats() != null ? f.getHabitats() : List.of());
            s.conservationStatus = f.getConservationStatus();
            return s;
        }

        /**
         * Applies this snapshot’s values back to a {@link Fish} object.
         *
         * @param f the {@link Fish} instance to restore to the snapshot state
         */
        void applyTo(Fish f) {
            f.setCommonName(commonName);
            f.setScientificName(scientificName);
            f.setAverageSize(averageSize);
            f.setMeasurementUnit(measurementUnit);
            f.setDiet(diet);
            f.setHabitats(new ArrayList<>(habitats));
            f.setConservationStatus(conservationStatus);
        }
    }

    //---- UTILITY METHODS----

    /**
     * Applies {@link NatureTheme} color styling to dialog headers safely.
     *
     * <p>Uses {@link Platform#runLater(Runnable)} to ensure UI updates
     * occur on the JavaFX Application Thread.</p>
     *
     * @param dp the {@link DialogPane} whose header region will be themed
     */
    private void safeHeaderStyle(DialogPane dp) {
        Platform.runLater(() -> {
            var header = dp.lookup(".header-panel");
            if (header != null) {
                header.setStyle("-fx-background-color: " + NatureTheme.PRIMARY_COLOR + "; -fx-text-fill: white;");
            }
        });
    }

    /**
     * Smoothly animates height transitions for expanding or collapsing resizable regions.
     *
     * @param region    the {@link Region} whose preferred height will be animated
     * @param newHeight the target height in pixels
     */
    private void animateHeight(Region region, double newHeight) {
        javafx.animation.Timeline timeline = new javafx.animation.Timeline(
                new javafx.animation.KeyFrame(
                        Duration.millis(250),
                        new javafx.animation.KeyValue(region.prefHeightProperty(), newHeight)
                )
        );
        timeline.play();
    }
}
