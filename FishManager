import java.util.*;

/**
 * FishManager.java
 *
 * Manages fish records using both local in-memory storage and a database backend
 * through the FishDAO class. Automatically switches between database and local
 * modes based on connection status.
 */
public class FishManager{

    /** Data Access Object handling both database and local operations. */
    private final FishDAO fishDAO;

    /** Local fallback list (used when database is unavailable). */
    private final List<Fish> fishList;

    /** Scanner for interactive CLI input. */
    private final Scanner scanner;

    /**
     * Constructs a FishManager using a provided FishDAO.
     * @param dao the data access object for fish records
     */
    public FishManager(FishDAO dao){
        this.fishDAO=dao;
        this.fishList=new ArrayList<>();
        this.scanner=new Scanner(System.in);
    }

    /**
     * Checks if the FishManager is currently using the database.
     *
     * @return true if database is connected, false if running in local mock mode
     */
    public boolean isUsingDatabase() {
        return fishDAO.isUsingDatabase();
    }

    /**
     * Updates a fish directly (used by FishManagerUI to persist field edits).
     * @param fish the fish to update
     * @return true if updated successfully
     */
    public boolean updateFish(Fish fish) {
        if (fish == null) return false;
        if (fishDAO.isUsingDatabase()) {
            return fishDAO.updateFish(fish);
        } else {
            for (int i = 0; i < fishList.size(); i++) {
                if (fishList.get(i).getTag().equals(fish.getTag())) {
                    fishList.set(i, fish);
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * Gets all fish, from database if available or from local list otherwise.
     * Always prefers DAO (even in mock mode) to ensure consistency in tests.
     *
     * @return the current list of Fish objects
     */
    public List<Fish> getFishList(){
        List<Fish> daoList = fishDAO.getAllFish();
        if (daoList != null && !daoList.isEmpty()) {
            return daoList;
        }
        return fishList;
    }

    /**
     * Adds a new fish record.
     *
     * @param fish the Fish object to add
     * @return true if successfully added, false otherwise
     */
    public boolean addFish(Fish fish){
        if(fish==null)return false;
        // Always attempt via DAO first — works for both real DB and mock mode
        boolean added = fishDAO.addFish(fish);
        if(!added && !fishDAO.isUsingDatabase()){
            return fishList.add(fish);
        }
        return added;
    }

    /**
     * Searches for a fish in the list or database by its tag.
     *
     * @param tag the tag to search for
     * @return the Fish object if found, null otherwise
     */
    public Fish findFishByTag(String tag){
        Fish found = fishDAO.findFishByTag(tag);
        if(found!=null)return found;
        for(Fish f:fishList){
            if(f.getTag().equals(tag))return f;
        }
        return null;
    }

    /**
     * Updates an existing fish identified by its tag.
     * Only valid or non-null values are applied.
     *
     * @param tag the tag identifying the fish to update
     * @param newCommonName new common name (letters only)
     * @param newScientificName new scientific name (letters only)
     * @param newAverageSize new average size (must be > 0)
     * @param newDiet new diet description
     * @param newHabitats new habitat list
     * @param newStatus new conservation status
     * @param newTag new tag in format 000-00-0000
     * @return true if the fish was found and updated, false otherwise
     */
    public boolean updateFishByTag(String tag,String newCommonName,String newScientificName,
                                   Double newAverageSize,String newDiet,List<String> newHabitats,
                                   String newStatus,String newTag){
        //  Always retrieve from DAO first (even mock mode)
        Fish existing = fishDAO.findFishByTag(tag);
        if (existing == null) {
            // fallback to local list only if DAO has none
            for (Fish f : fishList) {
                if (f.getTag().equals(tag)) {
                    existing = f;
                    break;
                }
            }
        }
        if(existing == null) return false;

        // Apply updates safely before saving
        if(newCommonName!=null&&newCommonName.matches("[a-zA-Z ]+"))existing.setCommonName(newCommonName);
        if(newScientificName!=null&&newScientificName.matches("[a-zA-Z ]+"))existing.setScientificName(newScientificName);
        if(newAverageSize!=null&&newAverageSize>0)existing.setAverageSize(newAverageSize);
        if(newDiet!=null&&!newDiet.isEmpty())existing.setDiet(newDiet);
        if(newHabitats!=null&&!newHabitats.isEmpty())existing.setHabitats(newHabitats);
        if(newStatus!=null&&!newStatus.isEmpty())existing.setConservationStatus(newStatus);
        if(newTag!=null&&newTag.matches("\\d{3}-\\d{2}-\\d{4}"))existing.setTag(newTag);

        //  Always save through DAO (works in mock or real mode)
        return fishDAO.updateFish(existing);
    }

    /**
     * Removes a fish from the list or database by tag.
     *
     * @param tag the tag of the fish to remove
     * @return true if the fish was removed, false otherwise
     */
    public boolean removeFishByTag(String tag){
        //  Always attempt DAO removal first (works in mock too)
        boolean daoRemoved = fishDAO.removeFishByTag(tag);
        boolean listRemoved = fishList.removeIf(f->f.getTag().equals(tag));
        return daoRemoved || listRemoved;
    }

    /**
     * Calculates the average number of habitats per fish.
     *
     * @return the average number of habitats per fish, or 0.0 if no data
     */
    public double calculateAverageHabitatsPerFish() {
        List<Fish> list = getFishList();
        if (list.isEmpty()) return 0.0;

        int totalHabitats = 0;
        for (Fish fish : list) {
            // Protect against null habitat lists
            if (fish.getHabitats() != null) {
                totalHabitats += fish.getHabitats().size();
            }
        }

        return (double) totalHabitats / list.size();
    }

    /**
     * Identifies the fish with the highest ecological diversity.
     * Diversity is calculated as (number of habitats × number of diet words).
     *
     * @return a string describing the most diverse fish or a message if no data
     */
    public String getTopDiversityFish() {
        List<Fish> list = getFishList();
        if (list.isEmpty()) return "No fish data available.";

        Fish topFish = null;
        int highestScore = 0;

        for (Fish fish : list) {
            int habitatCount = (fish.getHabitats() != null) ? fish.getHabitats().size() : 0;
            int dietCount = (fish.getDiet() != null) ? fish.getDiet().split("\\s+").length : 0;
            int score = habitatCount * dietCount;

            if (score > highestScore) {
                highestScore = score;
                topFish = fish;
            }
        }

        return (topFish != null)
                ? topFish.getCommonName() + " (score: " + highestScore + ")"
                : "No fish data available.";
    }

    /**
     * Calculates the average size of all fish.
     *
     * @return the average size, or 0.0 if the list is empty
     */
    public double calculateAverageSize() {
        List<Fish> list = getFishList();
        if (list.isEmpty()) return 0.0;

        double total = 0.0;
        for (Fish fish : list) {
            total += fish.getAverageSize();
        }

        return total / list.size();
    }

    /**
     * Finds duplicate tag numbers within the list or database results.
     *
     * @return a map of duplicate tags with their occurrence counts
     */
    public Map<String,Integer> getDuplicateTags(){
        List<Fish> list=getFishList();
        Map<String,Integer> tagCounts=new HashMap<>();
        for(Fish f:list){
            tagCounts.put(f.getTag(),tagCounts.getOrDefault(f.getTag(),0)+1);
        }
        tagCounts.entrySet().removeIf(entry->entry.getValue()<2);
        return tagCounts;
    }

    /** Displays all fish currently stored in the list or database. */
    private void listAllFish(){
        List<Fish> list=getFishList();
        if(list.isEmpty()){
            System.out.println("No fish added yet.");
            return;
        }
        System.out.println("\n--- All Fish ---");
        for(Fish fish:list){
            System.out.println(fish);
            System.out.println("---------------------");
        }
    }

    /** Searches for a fish by its tag and displays the result. */
    private void searchFishByTag(){
        System.out.print("\nEnter tag to search (~ to go back): ");
        String tag=scanner.nextLine();
        if(tag.equals("~"))return;
        Fish f=findFishByTag(tag);
        if(f==null)System.out.println("Fish not found.");
        else System.out.println("Found:\n"+f);
    }

    /** Allows the user to interactively update a fish’s name or diet. */
    private void interactiveUpdateFish(){
        System.out.print("Enter tag to update (~ to cancel): ");
        String tag=scanner.nextLine();
        if(tag.equals("~"))return;
        Fish f=findFishByTag(tag);
        if(f==null){
            System.out.println("No fish found with that tag.");
            return;
        }
        System.out.println("Updating fish: "+f.getCommonName());
        System.out.print("Enter new common name (blank to skip): ");
        String newCommon=scanner.nextLine().trim();
        System.out.print("Enter new diet (blank to skip): ");
        String newDiet=scanner.nextLine().trim();

        updateFishByTag(tag,
                newCommon.isEmpty()?null:newCommon,
                null,null,
                newDiet.isEmpty()?null:newDiet,
                null,null,null);
        System.out.println("Fish updated successfully.");
    }

    /** Allows the user to remove a fish record interactively. */
    private void interactiveRemoveFish(){
        System.out.print("Enter tag to remove (~ to cancel): ");
        String tag=scanner.nextLine();
        if(tag.equals("~"))return;
        boolean removed=removeFishByTag(tag);
        System.out.println(removed?"Fish removed successfully.":"Fish not found.");
    }

    /** Displays a report of duplicate tags, if any exist. */
    private void checkDuplicateTagsCLI(){
        Map<String,Integer> dupes=getDuplicateTags();
        System.out.println("\n--- Duplicate Tag Report ---");
        if(dupes.isEmpty())System.out.println("No duplicate tags found.");
        else dupes.forEach((tag,count)->System.out.println("Tag "+tag+" occurs "+count+" times."));
    }
}
